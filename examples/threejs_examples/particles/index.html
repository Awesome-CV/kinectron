<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - particles - waves</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			a {
				color:#0078ff;
			}
		</style>
	</head>
	<body>
		<script type="text/javascript" src="../../../client/bin/kinectron.bundle.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>

		<script src="../shared/Projector.js"></script>
		<script src="../shared/CanvasRenderer.js"></script>

		<script src="../shared/stats.min.js"></script>

		<script>
			var kinectron1, kinectron2;
			var handsTouching = false;

			var SEPARATION = 100, AMOUNTX = 50, AMOUNTY = 50;

			var container, stats;
			var camera, scene, renderer;

			var particles, particle, count = 0;

			var joints1 = [];
			var joints2 = [];

			var jointPositions1; 
			var jointPositions2;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var down = true; 

			init();
			animate();

			// window.addEventListener('mousedown', function() {
			// 	down = !down;
			// 	// if (down === true) down = false;
			// 	// if (down === false ) down = true;
			// });

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 650;
				camera.position.z = 800;

				scene = new THREE.Scene();

				particles = new Array();

				var PI2 = Math.PI * 2;
				var material = new THREE.SpriteCanvasMaterial( {

					color: 0xffffff,
					program: function ( context ) {

						context.beginPath();
						context.arc( 0, 0, 0.5, 0, PI2, true );
						context.fill();

					}

				} );

				var i = 0;

				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {

						particle = particles[ i ++ ] = new THREE.Sprite( material );
						particle.position.x = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
						particle.position.z = iy * SEPARATION - ( ( AMOUNTY * SEPARATION ) / 2 );
						scene.add( particle );

					}

				}

				var material2 = new THREE.SpriteCanvasMaterial( {

					color: 0xff0000,
					program: function ( context ) {

						context.beginPath();
						context.arc( 0, 0, 0.5, 0, PI2, true );
						context.fill();

					}

				} );

				for ( var j = 0; j < 25; j++ ) {
					var joint = new THREE.Sprite( material2 );
					joint.position.x = 0;
					joint.position.y = 0;
					joint.position.z = 300;
					joint.scale.x = 10;
					joint.scale.y = 10;
					scene.add( joint );
					joints1.push(joint);

				} 

				var material3 = new THREE.SpriteCanvasMaterial( {

					color: 0x0000ff,
					program: function ( context ) {

						context.beginPath();
						context.arc( 0, 0, 0.5, 0, PI2, true );
						context.fill();

					}

				} );

				for ( var j = 0; j < 25; j++ ) {
					var joint = new THREE.Sprite( material3 );
					joint.position.x = 0;
					joint.position.y = 0;
					joint.position.z = 300;
					joint.scale.x = 10;
					joint.scale.y = 10;
					scene.add( joint );
					joints2.push(joint);

				} 


				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				initKinectron();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function drawJoints1(data) {
			  //console.log(data);

			  for (var j = 0; j < joints1.length; j++ ) {
			    joints1[j].position.x = data.joints[j].cameraX = data.joints[j].cameraX * window.innerWidth/4;
			    joints1[j].position.y = data.joints[j].cameraY = data.joints[j].cameraY * window.innerHeight/4;
			    joints1[j].position.z = data.joints[j].cameraZ = data.joints[j].cameraZ * -window.innerWidth/4;
			  }

			  jointPositions1 = data.joints;

			}

			function drawJoints2(data) {
			  //console.log(data);

			  jointPositions2 = data.joints;

			  for (var j = 0; j < joints2.length; j++ ) {
			    joints2[j].position.x = data.joints[j].cameraX = data.joints[j].cameraX * window.innerWidth/4;
			    joints2[j].position.y = data.joints[j].cameraY = data.joints[j].cameraY * window.innerHeight/4;
			    joints2[j].position.z = data.joints[j].cameraZ = data.joints[j].cameraZ * -window.innerWidth/4;
			  }
			}


			function checkLandR(left, right) {
			    var p1L = getJointLocation(jointPositions1[left]);
			    var p2L = getJointLocation(jointPositions2[left]);

			    var p1R = getJointLocation(jointPositions1[right]);
			    var p2R = getJointLocation(jointPositions2[right]);

			    var col1 = checkCollisions(p1L, p2L);
			    var col2 = checkCollisions(p1L, p2R);
			    var col3 = checkCollisions(p1R, p2L);
			    var col4 = checkCollisions(p1R, p2R);

			    // console.log(col1, col2, col3, col4);
			  
			    if (col1 || col2 || col3 || col4) {
			      return true;
			    } else { 
			      return false;
			    }
			}

			function getJointLocation(joint) {
			  var newJoint = new THREE.Vector3( joint.cameraX, joint.cameraY, joint.cameraZ );
			  return newJoint;
			}

			function checkCollisions(j1, j2) {
				var dist = j1.distanceTo(j2);

			  if ( dist < 100 ) {
			    return true;
			  } else {
			    return false;
			  }

			}

			function initKinectron() {
				// Define and create an instance of kinectron
				//var kinectronIpAddress = ""; // FILL IN YOUR KINECTRON IP ADDRESS HERE
				kinectron1 = new Kinectron("10.0.1.14");

				// Connect remote to application
				kinectron1.makeConnection();
				kinectron1.startTrackedBodies(drawJoints1);

				kinectron2 = new Kinectron("10.0.1.4");

				// Connect remote to application
				kinectron2.makeConnection();
				kinectron2.startTrackedBodies(drawJoints2);
			}

			window.addEventListener('keydown', function(){
			  kinectron1.stopAll();
			  kinectron2.stopAll();

			});

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			//

			function animate() {

				if (jointPositions1 && jointPositions2) {
				  //check hands and feet
				  handsTouching = checkLandR(kinectron1.HANDLEFT, kinectron1.HANDRIGHT);
				  console.log(handsTouching);
				 // feetTouching = checkLandR(15, 19);
				}

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;
				//console.log(camera.position.y);
				camera.lookAt( scene.position );

				var i = 0;



				for ( var ix = 0; ix < AMOUNTX; ix ++ ) {

					for ( var iy = 0; iy < AMOUNTY; iy ++ ) {

						particle = particles[ i++ ];

						if (!handsTouching) {
							var dest = new THREE.Vector3(particle.position.x, 0, particle.position.z);
							particle.position.lerp( dest, 0.1 );

						} else {
							particle.position.x = ix * SEPARATION - ( ( AMOUNTX * SEPARATION ) / 2 );
							particle.position.y = ( Math.sin( ( ix + count ) * 0.3 ) * 50 ) +
								( Math.sin( ( iy + count ) * 0.5 ) * 50 );
							particle.scale.x = particle.scale.y = ( Math.sin( ( ix + count ) * 0.3 ) + 1 ) * 4 +
								( Math.sin( ( iy + count ) * 0.5 ) + 1 ) * 4;
	
						}

						

					}

				}

				renderer.render( scene, camera );

				count += 0.1;

			}

		</script>
	</body>
</html>